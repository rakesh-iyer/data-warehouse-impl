import java.io.*;
import java.lang.reflect.Field;
import java.util.*;
import java.nio.file.*;

public class DremelDW {


    // The Schema is a pure data struct. i.e.
    // We will start with a flat structure to start with.
    // We will add support for nested structures later.
    ColumnStore build(List<Object> records, Class schema) throws Exception {
        ColumnStore columnStore = new ColumnStore();
        Field[] fields = schema.getFields();
        for (Field field: fields) {
            String columnName = field.getName();
            columnStore.addColumn(new Column(columnName));
        }

        // We will need to add support for repeated and optional fields.
        for (Object record: records) {
            if (!schema.isInstance(record)) {
                throw new Exception("Record schema does not match");
            }
            for (Field field: fields) {
                String columnName = field.getName();
                Column column = columnStore.getColumn(columnName);
                column.addValue(field.get(record));
            }
        }
        return columnStore;
    }

    ColumnStore build(String columnStorePath) throws IOException {
        List<Object> records = new ArrayList<>();
        DirectoryStream<Path> columnStoreFiles = Files.newDirectoryStream(
                Paths.get(columnStorePath));
        ColumnStore columnStore = new ColumnStore();

        for (Path columnStoreFile: columnStoreFiles) {
            if (Files.isDirectory(columnStoreFile)) {
                // this is a bug.
                throw new IOException("Column store file" + columnStoreFile +
                        " should not be a directory");
            }
            FileInputStream fis =
                    new FileInputStream(columnStoreFile.toFile());
            // the last component of the path is the column name
            Path columnFilePath = columnStoreFile.getFileName();
            if (columnFilePath == null) {
                throw new IOException("Could not obtain the file name for " + columnStoreFile);
            }

            // construct ColumnStore with this information
            byte[] columnData = fis.readAllBytes();
            Column column = Column.build(columnFilePath.toString(),
                    columnData);
            columnStore.addColumn(column);
        }

        return columnStore;
    }


    void store(ColumnStore columnStore, String columnStoreDirectory) throws IOException {
        // what is the impact of the runtime exception generated by the lambda.
        columnStore.columnStore.forEach(
                (String columnName, Column column) ->
                        column.store(Paths.get(columnStoreDirectory).resolve(columnName)));
    }

    static class TestRecord {
        public int id;
        public String name;
        public int balance;
        TestRecord(int id, String name, int balance) {
            this.id = id;
            this.name = name;
            this.balance = balance;
        }
    }

    List<Object> getSomeTestRecords() {
        List<Object> testRecords = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < 1000; i++) {
            testRecords.add(new TestRecord(i, "record"+i, random.nextInt()));
        }
        return testRecords;
    }

    static class ColumnStore {
        // This could be a list but I think having it as a Map is more useful
        // long-term
        Map<String, Column> columnStore = new HashMap<>();

        void addColumn(Column column) {
            columnStore.put(column.name, column);
        }

        Column getColumn(String columnName) {
            return columnStore.get(columnName);
        }

        void printStats() {
            columnStore.forEach((String columnName, Column column) ->
            {
                System.out.println(columnName + "::" + column.numberOfRecords());
            });
        }

        Map<String, Object> aggregates() {
            Map<String, Object> aggregate = new HashMap<>();
            columnStore.forEach((String columnName, Column column) ->
            {
                aggregate.put(columnName, column.aggregate());
                System.out.println(columnName + "::" + column.aggregate());
            });
            return aggregate;
        }

        Map<String, Object> maximums() {
            Map<String, Object> maximums = new HashMap<>();
            columnStore.forEach((String columnName, Column column) -> {
                maximums.put(columnName, column.maximum());
                System.out.println(columnName + "::" + column.maximum());
            });
            return maximums;
        }

        Map<String, Object> minimums() {
            Map<String, Object> minimums = new HashMap<>();
            columnStore.forEach((String columnName, Column column) -> {
                minimums.put(columnName, column.minimum());
                System.out.println(columnName + "::" + column.minimum());
            });
            return minimums;
        }

        Map<String, Object> filtered(String filter) {
            Map<String, Object> filtered = new HashMap<>();
            columnStore.forEach((String columnName, Column column) -> {
                try {
                    filtered.put(columnName, column.filtered(filter));
                    System.out.println(columnName + "::" + column.filtered(filter));
                } catch (Exception e) {
                    System.out.println(e);
                }
            });
            return filtered;
        }
    }

    public static void main(String[] args) throws Exception {
        DremelDW dremelDW = new DremelDW();
        List<Object> testRecords = dremelDW.getSomeTestRecords();
        ColumnStore columnStore = dremelDW.build(testRecords, TestRecord.class);
        columnStore.printStats();
        String filter = "name > record100";
        Map<String, Object> aggregates =  columnStore.aggregates();
        Map<String, Object> maximums = columnStore.maximums();
        Map<String, Object> minimums = columnStore.minimums();
        Map<String, Object> filtered = columnStore.filtered(filter);
    }
}